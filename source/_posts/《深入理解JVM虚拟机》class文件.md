---
title: 《深入理解JVM虚拟机》class文件
date: 2018-10-19 10:13:58
tags: [JVM]
---
# 《深入理解JVM虚拟机》 class

.java编译后成为.class，江湖人称字节码文件。当虚拟机读取字节码后，转为二进制文件执行代码。那么字节码文件是怎样阅读呢？以及字节码文件在虚拟机中是怎么加载执行呢？这一部分讨论下虚拟机与class文件的关系。

# 类文件结构
[image:B2118612-8559-4534-B532-F0EE059DAE57-21700-0000497937AC42D4/7611B482-6B7D-4E5F-92F9-9745317C2A4E.png]

class文件是一组以8位字节为基础单位的二进制流。当遇到占用8位字节以上空间的数据项时，则按照高位在前的方式分割成若干个8位字节存储。
class文件格式伪结构体仅有两种数据结构：无符号数和表。
## 魔数和class文件版本
魔数的作用是确定该文件是否时能被虚拟机接受的class文件。位于前4个字节。
后4个字节代表class的版本号（5，6次版本号；7，8主版本号）；

## 常量池
常量池在版本号之后，可以理解为class文件的资源仓库。
入口是u2类型的数据，代表容量计数器（从1开始计数）。
常量池存放数据：字面量，符号引用。字面量较接近java语言的常量概念，如文本字符串，声明为final的常量值。
符号引用包括下面三类常量：类和接口的全限定名，字段名称和描述符，方法的名称和描述符。接口索引第一项是接口计数器，表示索引表容量。

## 访问标志
访问标志位于常量池结束后，用于识别一些类和接口层次的访问信息（如class是类还是接口，是否为pulic，是否定义abstract类型）

## 类索引，父类索引，接口索引集合
类索引、父类索引是一个u2类型的数据，接口索引是一组u2类型数据的集合，class文件由这三项来确定这个类的继承关系。
类索引确定类的全限定名；父类索引确定该类的父类全限定名，仅有一个（单继承）。
接口索引用来描述这个类实现了接口（按照implements顺序排列在集合）

## 字段表集合
字段表用于描述接口或类中声明的变量。包括类级变量以及实例级变量，但不包括方法内局部变量。
具体细节包括：字段作用域，类变量或实例变量（static），可变性，并发可见性（volatile）， 是否可被序列化，字段数据类型，字段名称。
理解全限定名，简单名称，描述符

## 方法表集合
同字段表类似。方法体存放在一个“code”的属性里面。

PS：重载的理解（JVM）
要重载一个方法，除要与原方法具有相同的简单名称外，还要求拥有一个不同的特征签名。特征签名是一个方法中各个参数在常量池中的字段符号引用的集合。由于返回值不会包含在特征签名中，所以Java无法仅依靠返回值不同对一个方法重载。
从class角度考虑，两个方法拥有相同的名称和特征签名，但是返回值不同，可以合法存在于同一个class文件。

## 属性表集合
class文件、字段表、方法表均可携带自己的属性表集合，以描述某些场景的专有信息。
….好好总结下，这里的内容有点多。。

# 虚拟机类加载机制
虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转化解析和初始化，最终形成可以被虚拟机直接使用的Java类型。
在Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的，虽然这样提升增加性能开销，但是提供高度的灵活性。Java可以动态扩展语言特性就是依赖运行期动态加载和动态。

## 类加载时机
加载，验证，准备，解析，初始化，使用，卸载。其中验证，准备，解析三个部分被统称为连接。
加载、验证、准备、初始化、卸载这几个阶段顺序是确定的，而解析则不一定，某些情况下可以在初始化之后再开始（此处是为了支持Java运行时绑定，反射？）。
### 加载时机
* new、getstatic，putstatic，invokestatic
* reflect
* 调用子类时，父类未被初始化
* main()所在类
* 部分解析句柄（jdk1.7支持的动态语言）
### 加载过程
加载是”类加载“的一个过程，主要完成三个工作：
* 通过一个类的全限定名来获取定义该类的二进制字节流
* 将这个字节流代表的静态存储结构转化为方法区运行时的数据结构
* 在内存中生成一个代表这个类的class对象，作为方法区中该类的数据访问入口

> 加载数组类情况有所不同，数组类本身有通过类加载器创建，而是通过虚拟机直接创建。

### 验证
验证阶段目的是为了确保class文件的字节流信息符合当前虚拟机的要求，切不会危害虚拟机安全。从整体上讲，大约分为下面4个方面：
* 文件格式验证（是否符合class文件格式规范）
* 元数据验证（语义描述信息符合语言规范）
* 字节码验证（通过数据流和控制流分析，确定程序合法且符合逻辑）
* 符号引用验证（对于符号信息进行匹配性校验）

### 准备
准备阶段是将正式为类变量分配内存并设置类变量初始值，这些变量所使用的内存均在方法区进行分配。（1、分配仅包括被static修饰的类变量；2、被final修饰的value会被直接初始化所指定的值）

### 解析
解析是虚拟机将常量池内的符号引用替换为直接饮用的过程。主要对象针对类或接口、字段、类方法、接口方法、方法类型、方法类型、方法句柄和调用点限定符7类进行饮用。

> 符号引用：符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时无奇艺的定位到目标即可。与虚拟机实现的内存布局无关，且引用的目标未必已经加载到内存中。
> 直接引用：直接饮用时可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接饮用是和虚拟机实现的内存布局相关的。如果有了直接饮用，则引用目标必定存在于内存中。

### 初始化
前面的类加载过程，绝大多数是由虚拟机主导和控制。到了初始化阶段，才开始真正执行程序代码（字节码）。执行类构造器<clinit>()方法。

## 类加载器
通过一个类的全限定名来获取描述此类的二进制字节流，此动作放到Java虚拟机外部实现，改部分代码模块被称为类加载器。

### 类与类加载器
对于任意一个类，都需要由加载该类的类加载器和本身一同确立其在虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。
比较两个类是否“相等”，只有在两个类是由同一个类加载器加载的前提下才有意义。否则即使两个类来源于同一个class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，则这两个类必定不想等。

### 双亲委派模型
从虚拟机角度而言，仅存在两种类加载器。启动类加载器及其他类加载器。启动类加载器是虚拟机的自身的一部分，而其他类加载器则独立于虚拟机外部。
在开发人员看来，类加载器可以继续划分。启动类加载器，扩展类加载器，应用程序类加载器。
[image:67BB4BDB-358D-4710-A30B-B9CE094833B2-49901-00004FB3BABC266D/A0168939-E93F-4364-9C2A-6BEC4118985A.png]

上图展示的类加载器之间的层次关系，被称之为双亲委派模型。双亲委派模型出了要求顶层的启动类加载器之外，其余类加载器都应当有自己的父类加载器。此处类加载器之间的父子关系并非继承，而是采用组合关系复用类加载器。

> 双亲委派模型工作原理：如果一个类加载器收到了类加载器的请求，首先并非自己去尝试加载，而是会将请求委派给父类加载器去完成，每一个类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法加载请求，子加载器才会尝试自己去加载。

### 破坏双亲委派模型
第一次被破坏是发生在双亲委派模型出现之前，即jdk1.2发布之前。
第二次被破坏时由于模型自身缺陷所导致。双亲委派模型可以很好的将已经加载好的基础类API被用户代码调用的问题。但如果基础类API需要回掉用户代码API，只能使用 “线程上下文类加载器”。原理是父类加载器请求子类加载器去完成加载类的动作。
第三次被破坏是由于用户对程序的动态性的追求而导致的。

# 字节码执行引擎
执行引擎是虚拟机最核心的组成部分之一。

## 运行时的栈帧结构
栈帧是用于虚拟机进行方法调用和方法执行的数据结构。是虚拟机栈的栈元素。栈帧储存了方法的局部变量表，操作数帧，动态连接和方法返回等信息。每一个方法从调用开始到执行完成的过程，都对应一个栈帧在虚拟机栈从入栈到出栈的过程。
对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的被称之为当前栈帧，与该栈帧关联的方法被称之为当前方法。执行引擎运行所有的字节码指令都指针对当前栈帧进行操作。

[image:072C6A7B-9D28-436B-B7B2-9B27D70F4161-49901-00005208F1823246/A4F94359-10A9-4A6D-A90C-507D460456C3.png]

### 局部变量表
局部变量表是一组变量的存储空间，用于存放方法参数和方法内部定义的局部变量。

### 操作数栈
### 动态连接
### 方法返回地址

## 方法调用
## 基于栈的字节码解释执行引擎
