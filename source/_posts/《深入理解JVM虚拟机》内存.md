---
title: 《深入理解JVM虚拟机》内存
date: 2018-09-03 18:08:30
tags: [JVM]
---
有关《深入理解JVM虚拟机》的相关理解
可以将书中内容分为几个的知识块来学习。
内存：
	包括内存模型、内存管理、内存回收
JVM与class：
	class文件结构、类文件加载机制、字节码执行方式
多线程与并发：
	多线程、线程调度机制、线程安全
编译优化

## 内存
我们先来讨论虚拟机中的内存相关信息。在本书中，内存是占据内容的第一版面。正如作者所说，“内存管理者这堵高墙，墙外的人想进来，墙里的人想出去”。
我们通常将虚拟姐的内存划分为五块：程序计数区、虚拟机栈、本地方法去、java堆、方法区。其中虚拟机栈、本地方法栈、程序计数器为线程隔离状态，Java堆及方法区则是线程共享区。

### 程序计数器
程序计数器仅占用内存中较小的一块内容，可看为字节码的行号指示器。在概念模型中，字节码解释器通过改变计数器的值来选择接下来执行的字节码指令。
Java虚拟机多线程通过线程轮流切换后，分配CPU的执行时间完成。为了线程切换后可以恢复到正确的执行位置，因此每条线程拥有独立，互不影响的程序计数器，我们称之为“线程私有”。

### Java虚拟机栈
虚拟机栈描述的是java方法执行时的内存模型，生命周期与线程相同。每个方法执行时会创建一个栈帧，用于存放局部变量表、操作数栈、动态链接、方法出口等。方法从调用到结束，队形一个栈帧在虚拟机栈入栈到出栈的过程。

### 本地方法栈
本地方法栈描述的是虚拟机的Native方法运行时的内容从模型，与虚拟机栈类似。

### Java堆
Java Heap是J虚拟机管理内存中最大的一块，是被所有线程所共享的区域。作用为创建实例对象。（就是被new的对象都放在这里），因此也是内存回收的工作领域，别名GC堆（垃圾堆）

### 方法区
方法区存放虚拟机加载的类信息、常量、静态变量等。
运行时常量池是方法区的一部分，用于存放编译器生成的符号引用，这部分内容在类加载后进入运行时常量池。

###  对象创建、内存布局、访问定位

对象创建

1、接收到虚拟机new指令，首先检查指令参数能否定位到类的符号引用，并且检查所在类是否已被加载、解析和初始化。  
2、虚拟机为对象分配内存，需要了解“空闲列表”（Java堆不规整）以及“指针碰撞”（Java堆工整）
3、注意并发时加锁
4、将分配的内存空间初始化为零值
5、虚拟机设置对象头(类信息、哈希吗、CG年龄)
6、执行<init>方法
---
对象内存布局

对象头、实例数据、对齐填充
---
对象访问定位

使用句柄定位：划分出部分内存作为句柄池，存储对对象的句柄地址（类比数据库索引），GC时对象内存位置改变，仅仅改变句柄指针。
使用直接指针：存储地址对象，访问速度更快

### OutOfMemoryError（堆溢出、虚拟机栈及本地方法区溢出、方法区溢出、直接内存溢出）
Java堆溢出

---
虚拟机栈和本地方法栈溢出

方法区溢出

直接内存溢出


### GC（垃圾回收算法）

 对象回收状态
什么状态下的对象会被GC回收呢？这部分来探究回收时对象的状态。
### 引用计数算法（引用新概念）
引用概念扩充：强引用（Strong）、软引用（Soft）、弱引用（Weak）、虚引用（Phantom）
算法：给对象添加引用计数器，当有地方引用时+1，引用失效时-1。当计数器为0时表示不可再使用。

### 可达性分析算法
通过一系列“GC Roots”的对象作为起始点，从这部分节点开始向下搜索，搜索走过的路径被称之为引用链。当一个对象到GC Roots没有引用链能够到达，证明对象不可用。

### 对象自救
对象死亡需要经过两次标记，无引用链为第一次标记。之后判断对象是否有必要执行finalize()方法，这是第二次标记。
因此当对象在第一次标记后，执行finalize()可以暂时留住自己的一条狗命。但是该方法仅可被调用一次，之后不会被执行。（PS：第二次回收时谁也救不了这个对象）

### 方法区的回收
方法区常常被人们称为是永久代。垃圾回收的效率极低。
主要回收内容：废弃常量和无用的类。

## GC方法
集中简单回收的算法思路

### 标记-清除算法
标记出所有需要回收的对象，在完成后回收被标记对象。
缺点：1、标记和回收的效率较低
2、GC后会产生大量不连续内存碎片，无法容纳大对象，引发第二次GC

### 复制算法
将可用内存按容量分为大小两块。当一块使用完，将存活的对象复制到另一块内存，再将已经使用过的内存一次性清除。
优点：不考虑碎片，回收简单，效率高。
缺点：内存折半使用，成本太高。

当今复制算法：
将内存分为一个Eden和两个Survivor，比例为（8:1:1），每次使用Eden和一块Survivor，当回收时，将Eden和Survivor存活的对象一次性复制到另一块Survivor上，再清除Eden和Survivor。当Survivor不够用时，需要依赖其他内存进行分配担保。

### 标记-整理算法
针对“老年代”，采用标记整理算法。标记过程同之前一样，之后让所有存货对象向一端移动，清理掉边界外的内存。
优点：老年代的对象存活较多，不适合复制算法，适合标记整理；
碎片较小

### 分代收集算法
新生代：复制算法
老年代：标记-整理
永久代；标记-整理，标记-清除

## 垃圾回收器
图床有空优化。。。

不用的收集器适用于不同的年龄代；且不同收集器某些才可以互相搭配。具体回收较为复杂。

## 内存分配策略
* 对象优先分配在Eden
当Eden区空间不够，发起minor GC（新生代GC）
* 大对象直接进入老年代
很长的string或者数组，虚拟机直接让其老年代。
* 长期存活对象进入老年代
每经历一次minor GC，年龄加1。在15岁（默认）后，进入老年代
* 动态对象年龄判断
* 空间分配担保








